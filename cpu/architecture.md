# Architecture에 대해 다룹니다.<br>RICS-V Assembly code 기준으로 작성되었습니다.

## assembly language란?

인간이 읽을 수 있도록 표현된 컴퓨터 언어.

기계어는 0 혹은 1밖에 없음. 이를 사람이 읽을 수 있도록 만든 것이 어셈블리 언어.

고급언어(C, Verilog, python etc...)는 이를 더 추상화하여 만든 언어.

어셈블리 언어는 한 두개로 정해진 언어가 아니며, cpu에 따라서 다르다. 이는 뒤에서 서술.

## compile

인간이 읽을 수 있는 언어를 컴퓨터가 읽을 수 있는 언어로 만드는 과정.

고급언어의 경우, compile을 하면, 고급언어 -> 어셈블리 -> 기계어 과정을 거치게 된다.

## 기본적인 구조

기본적으로 다음과 같은 형식을 따른다.

ex)

    a = b + c;     -->    add, a, b, c
    
    a = b - c;     -->    sub, a, b, c


포맷은 다음과 같다.

{연산, 연산 결과 레지스터, 입력값 레지스터, 입력값 레지스터 혹은 즉시값}

입력값 레지스터는 cpu에 저장된 레지스터에서 가져오는 값.

즉시값은 레지스터에서 가져오는 값이 아닌, 연산 자체에 있는 값. // 만약 어떤 연산이 어떤 입력값에 항상 5를 더하는 연산이라고 하면, 즉시값은 5

### 위와 같은 형식은, R, I, S, B, U, J type에 적용되지만, pseudo instruction에는 적용되지 않음!! <br><br> 그러나, pseudo instruction일지라도 실제로는 위와 같은 형식으로 풀어짐!!<br> 또한, sw lw같은 경우도 위와 같은 형식이 적용되지 않음!!

R I S B U J type, pseudo instruction, sw lw 등은 뒤에서 서술.

## 레지스터

다음과 같은 연산을 보자.

    a = (b+c) - (d+e);

a 부터 e까지의 변수가 s0 부터 s4까지의 레지스터에 저장된다고 가정한다.

이를 어셈블리로 바꾼다면,

    add, t0, s1, s2

    add, t1, s3, s4

    sub, s0, t0, t1

이렇게 된다.

여기서, 연산을 할 때 변수가 아닌, 레지스터를 지정해서 사용했다.

어셈블리에서는 레지스터 안의 값을 지정하는 게 아닌, 레지스터 그 자체를 지정해서 사용해야 함!

## 즉시값

레지스터 혹은 메모리 접근을 하지 않고 연산을 수행하기 때문에 상대적으로 연산속도가 빠를 수 있음

다음과 같은 예시를 보자.

    a = 1024;

이를 어셈블리로 쓰면,

    addi, s0, zero, 1024 

여기서 s0은 변수 a가 있는 레지스터이고, addi는 즉시값을 사용하는 add이다. 여기서, addi는 12비트까지만 넣을 수 있음.

13~32비트까지는 lui를 이용하여 생성해야함! // lui : Load Upper Immediate이고, 20비트 즉시값을 생성 가능.

예를 들어서,

    a = 0xABCDE333;

이를 어셈블리로 쓰면,

    lui, s0, 0xABCDE

    addi s0, s0, 0x333 이 된다.

## 메모리

레지스터 뿐만 아니라 메모리도 사용 가능.

RISC-V에서는 32비트 메모리 주소, 32비트 데이터 워드 사용함.

RISC-V는 바이트 주소 지정 가능 메모리를 사용. (byte-addressable)

32비트 워드는 4개의 8비트 바이트로 구성되므로 각 워드의 주소는 4의 배수. 관례적으로 메모리는 낮은 메모리 주소를 아래로, 높은 메모리 주소를 위로 향하게 함.

lw(load word)는 메모리에서 레지스터로 한 워드를 로드함.

예를 들어서,

    a = mem[2];

이를 어셈블리로 쓰면

    lw s0, 8(zero) 

offset(base register)에서 이는 메모리 주소를 의미함. // 지번 주소 기준으로, xx시 xx구 xx동 y - n 번지에서, base register는 y, offset은 n이라고 생각하면 됨.

sw(store word)는 레지스터의 데이터를 메모리에 저장.

예를 들어서,

    mem[5] = 42;

이를 어셈블리로 쓰면

    addi t3, zero, 42

    sw t3, 20(zero)

위와 같은 형식으로 쓸 수 있음.

## 왜 32비트인가??

### 8비트당 1바이트 --> 32비트는 4바이트

대부분의 시스템은 정보 처리 단위가 1바이트 단위.

### {연산, 연산 결과 레지스터, 입력값 레지스터, 입력값 레지스터 혹은 즉시값} 이와 같은 형태는 4바이트 인코딩

어셈블리에서 lw, sw같은 예외처럼 보이는 것일지라도 실제로는 4바이트 인코딩

인자가 3개든 4개든 여러개든 최종적으로는 4바이트 인코딩

